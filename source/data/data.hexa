// The Hexa Compiler
// Copyright (C) 2021-2022 Oleg Petrenko
// Copyright (C) 2018 Bogdan Danylchenko
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, version 3 of the License.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

// TODO refactor to nodes.
// TODO move to nodes.hexa
/// Syntax tree
// TODO unindent
enum Node {
	/// `"text"`
	String(text: String)

	/// `ident`
	Ident(name: String)

	/// `ident<T>`
	ParametricIdent(name: String, params: [NodeType])

	/// `true`/`false`
	Bool(bool: Bool)

	/// `this`
	This

	/// `super`
	Super

	/// `123`
	Int(number: Int)

	/// `123n`
	/// `123u32`
	MetaInt(number: BigInt, meta: Meta)

	/// `0.123`
	Float(number: Float, meta: Meta)

	/// `null`
	Null

	/// `declare Alias = Value`
	TypeAlias(alias: NodeType, value: NodeType)

	/// `left op right` like `a + b`
	// TODO rename to `Binary` or `Infix`
	Binop(left: Node, op: Token, right: Node)

	/// `storage op= value`
	AssignOp(storage: Node, op: Token, value: Node)

	// { el[0] ... el[n] }
	Block(el: [Node])

		// e(args[0], ...args[n])
		Call(e: Node, args: [Node], argNames: [String])

		/// if econd[0], ...econd[n] { eif } [else { eelse }]
		If(econd: [Node], eif: Node, eelse: Node?, ternary: Bool)

		/// `(inner)`
		Parenthesis(inner: Node)

		/// `return e`
		Return(e: Node?)

		/// `throw e`
		Throw(e: Node)

		/// `break`
		Break

		/// `continue`
		Continue

		// postfix ? e op : op e
		// TODO rename to `Unary`
		Unop(op: Token, postfix: Bool, e: Node)

		// while reason { e } or if pre == true then do { e } while reason
		While(reason: Node, e: Node, pre: Bool)

		// `declare fun name<params>(vars): retType { body }`
		// Name is `new` for constructor
		// TODO expr Node.Block (goal is *not* to `Node extends NodeBlock` but to actually limit tags)
		Function(name: String?, body: Node, vars: [Node], retType: NodeType, external: Bool)

		// (vars): rettype => { expr }
		Arrow(expr: Node, vars: [Node], retType: NodeType)

		// [declare] (const ? let : var) name: t = expr
		Var(name: String, t: NodeType, expr: Node, const: Bool, external: Bool)

		// external class t extends extend implements implement { fields }
		Class(t: NodeType, extend: NodeType?, implement: [NodeType], fields: [Node], external: Bool, kind: ClassKind)

		// var name: T { get { return x } set (v) {} }
		// Var, Function, Function
		Property(field: Node, getter: Node, setter: Node)

		// try { expr } catch v[0]: t[0] { catches[0] } ... catch v[n]: t[n] { catches[n] }
		Try(expr: Node, t: [NodeType], v: [Node], catches: [Node])

		/// `expr.name`
		Dot(expr: Node, name: String)

		// expr.Name
		DotUpper(expr: Node, name: String)

		// new t { } (args)
		New(path: [String], t: NodeType, args: [Node], fields: [String], el: [Node], argNames: [String])

		// [elements[0], ...elements[n]]
		Array(elements: [Node])

		// [keys[0] : values[0], ... keys[n] : values[n]]
		Map(keys: [Node], values: [Node])

		// expr[index]
		Index(expr: Node, index: Node)

		// switch exprs[0], exprs[n] {
		//     case cases[0]: conds[0]
		//     case cases[n]: conds[n]
		// }
		Switch(exprs: [Node], conds: [Node], guards: [Node], cases: [Node])

		// module path[0].path[1].r..path[n] { el }
		Module(path: String, el: [Node])

		// Not present in syntax, used for typing
		ModuleExports(handle: Module)

		// import xxx as yyy in "test"
		Import(el: [ImportNode], path: String)

		// { name[0]: el[0], name[1]: el[1], ... name[n]: el[n] }
		// NOTE: Do not use Map here
		Object(names: [String], el: [Node])

		// enum t : valuesType extends extend { fields[0] ... fields[n] }
		Enum(t: NodeType, fields: [Node], valuesType: NodeType, extend: NodeType?)

		// let expr(extract[0], ..., extract[n]) = name
		EnumExtract(path: [String], bind: [Node/*.Var*/], expr: Node)

		/// `expr is T`
		Is(expr: Node, aType: NodeType)

		/// `expr as T`
		/// `expr as? T`
		/// `expr as! T`
		As(expr: Node, kind: Token, toType: NodeType)

		/// `_`
		Underscore

		/// `...`
		Interval

		/// `static` field
		Static(field: Node)

		/// `private` field or type
		Private(field: Node)

		// for name in over by
		// for name in over ... range by
		For(name: String, over: Node, by: Node, range: Node)

	/// `nullable ?? othewise`
	Elvis(nullable: Node, otherwise: Node)

	/// `T<A, B>` but as expression
	NodeTypeValue(type: NodeType)

	/// Produces readable string representation for node
	// TODO to non-static method
	static fun stringify(node: Node): String {
		switch node {
			case String(s): return "'\(s)'"
			case Ident(name): return name
			case Bool(b): return b? "true" : "false"
			case Int(s): return s.toString()
			case Float(s): return s.toString()
			case Null: return "null"
			case This: return "this"
			case Parenthesis(expr): return "(" + Node.stringify(expr) + ")"
			case Index(expr, index): return Node.stringify(expr) + '[' + Node.stringify(index) + ']'
			case Dot(expr, name): return Node.stringify(expr) + '.' + name
			case DotUpper(expr, name): return Node.stringify(expr) + '.' + name
			case Call(e, args, argNames):
				let arg = []
				for i in args.length {
					if let name = argNames[i] {
						arg.push(name + ': ' + Node.stringify(args[i]))
					} else {
						arg.push(Node.stringify(args[i]))
					}
				}
				return Node.stringify(e) + '(' + arg.join(', ') + ')'
			case Array(elements): return '[' + [for el in elements Node.stringify(el)].join(', ') + ']'
			case Binop(a, op, b): return Node.stringify(a) + ' ' + Token.stringify(op) + ' ' + Node.stringify(b)
			case Object(names, el):
				return '{' + [for i in el.length names[i] + ': ' + Node.stringify(el[i])].join(', ') + '}'
			case NodeTypeValue(t):
				return DataHelper.extractTypeName(t)
			case Static(f): return 'static ' + Node.stringify(f)
			case _:
				return "..."
		}
	}
}
