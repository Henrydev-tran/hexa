// The MIT License
//
// Copyright (C) 2022 Oleg Petrenko
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// TODO declare ConstArrayPointer<UInt16> = ConstPointer<WideChar>; request critics
// func<T> parse; Type -> class-like enum for decorators + arr[operator]
// if( while( as! _ ; var textFontList = null as! TextFontList early infer var:T
// --- vscode/subl upload+howto/autorun(checkbox:use port)[decorators to Map not[Decs]]
// separate Type for numbers? bits, signed
// Meta //

// TODO syntax highlight the part after `#if` and `#elseif`
#if bit64
	#if bit32
		#error 'cannot be both 32-bit and 64-bit, check `defines` section of `hexa.json` or `--define` arguments'
	#end
#end

//@rename('pointerOf')
//@header('#define pointerOf(v) (&(v))')
//@nativeGeneric
//@builtin
//// TODO autocomplete for @decorators
//declare fun pointerOf<T>(value: T): Pointer<T>

//@rename('constPointerOf')
//@header('#define constPointerOf(v) (&(v))')
//@nativeGeneric
//declare fun constPointerOf<T>(value: T): ConstPointer<T>

@rename('sizeOf')
@header('#define sizeOf(v) sizeOf(v)')
@nativeGeneric
declare fun sizeOf<T>(): UInt64 // TODO UInt32

@rename('dereferenceOf')
@header('#define dereferenceOf(v) (*(v))')
@nativeGeneric
declare fun dereferenceOf<T>(value: T): @byValue T
//@:native("::hx::AddressOf")
//	static function addressOf<T>(t:T):RawConstPointer<T>;
//@rename('arrayByValue')
//@header('#define arrayByValue(args...) { args }')
// #define eprintf(...) fprintf (stderr, __VA_ARGS__)
//@nativeGeneric
// TODO in codegen: check one-or-N args
//declare fun arrayByValue<T, size /* TODO : UInt32*/>(...values: T): ArrayByValue<T, size>

// Basic //

@struct
declare class ConstArrayPointer<T> {

}

// TODO declare class ArrayPointer<T> extends ConstArrayPointer<T> {
@struct
declare class ArrayPointer<T> {

}

declare class ByValue<T> {

}

@struct
declare class ConstArrayByValue<T, size> {
}

// TODO declare class ArrayByValue<T, size> extends ConstArrayByValue<T, size> {
@struct
@byValue
declare class ArrayByValue<T, size> {
//	fun asPointer(): Pointer<T>
//	fun asArrayPointer(): ArrayPointer<T>
}

//declare class ArrayByValuePointer<T> {
////	fun pointerOf(): Pointer<T>
//}

//eclare class ArrayByValuePointerChecked<T, size> {
//
//

@final
//@rename('void')
@nativeBasicType
declare class Void {}

@final
//`@rename('void*')`
@unsupported
declare class Any {}

//@final
//@nativeArrayIndexRead(T)
////@nativeMapIndexRead(T)
//@nativeArrayIndexWrite(T)
//declare class PointerArray<T> {}

@keep class AnyRef {
	//var meta: UInt64
	//var ref: UInt32
	//var xxx: (()=>Void)? // TODO Expected `=>` before `?`
}
@keep fun ref(object: AnyRef) {}
@keep fun unref(object: AnyRef) {}

@final
//@rename('int32_t')
@nativeBasicType // @keepFieldsOrder
@orderingSizeOf(32)
declare class Int {
}

declare class Int32 {}
declare class UInt32 {}
declare class UInt16 {}
declare class Int16 {}
declare class UInt8 {}
declare class Int8 {}

@final
//@rename('int32_t')
@nativeBasicType
declare class Bool {
	fun toZeroOrOne(): UInt8
}

/// Stored as `Int32` on native platforms
// TODO enum? Bool32?
@nativeConvertibleTo(Bool)
@nativeConvertibleFrom(Bool)
declare class CBool {}

// TODO
// > null == true
// false
// > null == false
// false
// thus null = 3

//enum CBool32: Int32 {
//	False = 0
//	True = 1
//}

@final
//@rename('double')
@nativeBasicType
declare class Float {}

@final
@nativeBasicType
declare class Float32 {
	fun toString(): String
}

@final
@nativeBasicType
// TODO just @native @nativeType
declare class UInt64 {}

@final
@nativeBasicType
declare class Int64 {
	fun truncateToInt16(): Int16
	fun truncateToInt8(): Int8

	fun truncateToUInt16(): UInt16
	fun truncateToUInt8(): UInt8
}

@final
@nativeConvertibleTo(String)
@nativeConvertibleFrom(String)
/*
//@nativeArrayGet()
@rename('const char *')
declare
class ConstArrayPointer<UInt8> {}
*//*
@rename('const wchar_t *')
declare
class ConstArrayPointer<UInt16> {
	fun charCodeAt(index: Int): Int? // TODO body TODO u16
	fun charCodeAtOrZero(index: Int): Int // TODO body TODO u16
}*/

//@rename('const wchar_t *')
//declare class ConstWideCharArray {
//	//fun unsafeGet(): Void
//}

/*@rename('char *')
declare
class ArrayPointer<UInt8> {}
*/
@rename('char')
declare
class ClangChar {}
/*
// TODO remove Char type, keep only UInt8, Char8 and WideChar/////Char16
*/
/*
// Separate non-UInt8 type to not be used as a number
@rename('char8_t')
declare
class Char8 {}

@rename('wchar_t *')
declare
class ArrayPointer<UInt16> {}
*/
@rename('wchar_t')
declare
class ClangWideChar {}

//@rename('const void *')
//declare
//class ConstVoidPointer extends Pointer<Void> {}

// TODO Cause we cannot Generic<Void>? Or just for conveience (better typecheck and documentation)?
// Generic<Void> in terms of dereferencing to Void is not possible?
// ^ simply no-nop (if `declare`d) or disable deref with `static if`
// otherwise just makes confusion
//@rename('void *')
//declare
//class RuntimeAllocated extends ConstVoidPointer {
//	@to(Pointer<Void>) // TODO implement
//	fun toPointerVoid(): Pointer<Void>
//	@from(Pointer<Void>) // TODO implement
//	static fun fromVoidPointer(pointer: Pointer<Void>): RuntimeAllocated
//	static let nullPtr: RuntimeAllocated
//	static fun fromAddress(at: UInt64): RuntimeAllocated // TODO UInt32
//}
/*
@rename('Pointer')
@header('TODO')
declare
class Pointer<T> {
	fun unwrap(): T?

	fun unwrapUnsafe(): T
	fun read(): T? // TODO mark as unsafe operaton?
	fun write(value: T): Void // TODO mark as unsafe operaton?

	fun unwrapOrCrashIfNull(): T
	fun throwIfNull(): T
	fun address(): UInt64 // TODO UInt32
	fun address64(): UInt64 // To keep logic same on evry platform

	fun offsetBySelfSizes(count: UInt64): Pointer<T> // TODO UInt32
	fun offsetByBytes(count: UInt64): Pointer<T> // TODO UInt32

	static fun pointerOf<T>(value: T): Pointer<T>
	static fun of<T>(value: T): Pointer<T>

	//fun unwrapUnsafely_extraLongNameToEasilySpotThis(): T
	//fun unwrapUnsafely_and_make_debugging_harder(): T
	//static fun of(to: T): Pointer<T> fromAddress
}
*/
// `arr[]` in C
// TODO ArrayPointer extends Pointerm so `sinlgePtr = arrPtr` like in C
/*declare
class ArrayPointer<T> {
	fun pointerOf(): Pointer<T>
}*/
/*
declare
class ConstArrayPointer<T> {
	fun pointerOf(): Pointer<T>
}
*//*
declare
class StructByValue<T> {
	//static fun of(to: T): ConstPointerPointer<T>
	//static fun of(to: T): T
}
*//*
declare
class ConstPointer<T> {
	fun offsetBySelfSizes(count: UInt64): ConstPointer<T>
	fun offsetByBytes(count: UInt64): ConstPointer<T> // TODO UInt32
	//static fun of(to: T): ConstPointerPointer<T>
	//static fun of(to: T): T
}
*/
@rename('size_t')
declare
class SizeOfPointer {
	fun toInt(): #if bit32 UInt32 #else UInt64 #end
}

@rename('struct')
declare
class Embed<T> {}

//@rename('malloc') declare fun malloc(size: Int): RuntimeAllocated
//@rename('malloc') declare fun malloc(size: SizeOfPointer): RuntimeAllocated
//@rename('strlen') declare fun strlen(string: ConstArrayPointer<UInt8>): SizeOfPointer
//@rename('memcpy') declare fun memcpy(dst: ConstArrayPointer<UInt8>, src: ConstArrayPointer<UInt8>, size: SizeOfPointer): Void

@rename('printInt') declare fun printInt(val: Int): Void
@rename('malloc') declare fun malloc(size: UInt64): RuntimeAllocated
// TODO rename to HeapAllocated?
@rename('free') declare fun free(pointer: RuntimeAllocated): Void
@rename('strlen') declare fun strlen(string: ConstArrayPointer<UInt8>): Int
@rename('wcslen') declare fun wcslen(string: ConstArrayPointer<UInt16>): Int
@rename('memcpy') declare fun memcpy(dst: ArrayPointer<UInt8>, src: ConstArrayPointer<UInt8>, size: Int): Void

//@rename('const char *')
declare class CString8 {}
declare class StackAsciiString {}
declare class HeapAsciiString {}

@final
@nativeFrom(String)
@nativeTo(String)
declare class CString16 {}

/*
	#if external_std_dll // or attach different string.hexa/stringdll.hexa|stringlib.hexa
		declare private class ExtrenalBuiltinStringPointer {}
		declare private fun ExtrenalBuiltinStringPointer_toUpperCase(...)
		@inline class String {
			let me: ExtrenalBuiltinStringPointer
			@inline new () {
			}
			@inline fun toUpperCase(): String
				return ExtrenalBuiltinStringPointer_toUpperCase(me)
			...
		}
	#else
		class String { ...
	#end

	TODO syntax `markdonw` in multiline comments?
*/

@final // TODO optimize into non-virtual calls
class String {
	// TODO `let length: Int` ?
	//var length: SizeOfPointer = 0 as! SizeOfPointer
	var length: UInt32 = 0

	/// Approximately 2 gigabytes + `\0`, also fits into 31-bit as a value
	static let defaultLimit: UInt32 = 1073741824u32

	/// Used for runtime purposes
	@keep private var next: String? = null as! String
	@keep private var bytesLength: Int = 0
	@keep private var bytesHash: Int = 0
	@keep private var bytes: ConstArrayPointer<UInt16> = null as! ConstArrayPointer<UInt16>
	//fun getBytesPointer(): Int {return 0}

	// TODO `@to(ConstArrayPointer<ClangWideChar>)` so allows to call without `.wide`
	// ^ fix tofitaDebugLog calls in Tofita
	@to(ConstArrayPointer<ClangWideChar>)
	fun wide(): ConstArrayPointer<ClangWideChar> {
		return bytes as! ConstArrayPointer<ClangWideChar>
	}

	fun utf16(): ConstArrayPointer<UInt16> {
		return bytes
	}

	fun utf8(): Buffer {
		// TODO implement!
		return Buffer.alloc(this.length as! Int)
	}

	//fun toUpperCase(): String TODO typer not errors here!
	fun toUpperCase(): String {return''}
	fun toLowerCase(): String {return''}
	fun charAt(index: Int): String {return''}
	// TODO `@weak` for other fun
	fun indexOf(@weak str: String, startIndex: Int?): Int {return 0}
	fun lastIndexOf(str: String, startIndex: Int?): Int {return 0}
	fun split(delimiter: String): [String] {return []}
	fun toString(): String {return this}
	fun substring(startIndex: Int, endIndex: Int?): String {return''}
	static fun fromCharCode(code: Int): String {return''}
	// TODO overloads
	// static fun fromCharCode(code: Int, code: Int): String {return''}
	// static fun fromCharCode(code: Int, code: Int, code: Int): String {return''}
	// static fun fromCharCode(code: Int, code: Int, code: Int, code: Int): String {return''}
	// static fun fromCharCode(...codes: Int): String {return''}
	fun charCodeAt(index: Int): Int? {return 0}
	fun trim(): String {return''}
	fun substr(pos: Int, len: Int?): String {return''}
	fun endsWith(str: String): Bool {return false}
	fun startsWith(str: String): Bool {return false}

	// Runtime functions
	private fun fromInt() {}

	private new () {
		// TODO set `length` here
		// TODO `length` must be immutable after construction
	}

	static fun fromUTF8z(string: ConstArrayPointer<UInt8>): String {
		// TODO replace call `strlen` with `countUTF16z` oh wait it's *8*-bit!
		let size: UInt32 = strlen(string as! ConstArrayPointer<ClangChar>)
		// TODO test type check that constructor is private
		let result = new String()
		let bytes = malloc(size * 2 + 2) as! ArrayPointer<UInt16>

		// TODO proper convert
		for i in size {
			bytes[i] = string[i]
		}

		bytes[size + 1] = 0
		result.bytes = bytes as! ConstArrayPointer<UInt16>
		result.length = size
		return result
	}

	static fun countUTF16zUpTo(string: ConstArrayPointer<UInt16>, limit: UInt32): UInt32 {
		// TODO stop at UINT32_MAX or define MAX_STRING_LENGTH
		// var size = 1u32 // TODO starts from 1? Nope, fromUTF16 adds own `\0`
		var i = 0u32
		while string[i] != 0 and i < limit {
			i++
		}
		return i
	}

	static fun countUTF16z(string: ConstArrayPointer<UInt16>): UInt32 {
		return countUTF16zUpTo(string, defaultLimit)
	}

	static fun fromUTF16(string: ConstArrayPointer<UInt16>, offset: UInt32, chars: UInt32): String {
		//@rename('malloc') declare fun malloc(size: Int): RuntimeAllocated
		//let size: Int = wcslen(string)
		//var size: Int = 1
		//var i = 0
		//while string[i] != 0 {
		//	size++
		//	i++
		//}

		let size = chars
		let result = new String()
		 //malloc(256/*sizeOf(String)*/) as! String
		//result.bytes = malloc(((size as! Int) + 1) as! SizeOfPointer) as! ConstArrayPointer<UInt8>
		result.bytes = malloc(size * 2 + 2) as! ConstArrayPointer<UInt16>
		let bytes: ArrayPointer<UInt16> = result.bytes as! ArrayPointer<UInt16>
		if size > 0 {
			// TODO respect offset !!!
			memcpy(bytes as! ArrayPointer<UInt8>, string as! ConstArrayPointer<UInt8>, size * 2)
		}
		bytes[size] = 0
		result.length = size
		return result
	}

	static fun fromUTF16zUpTo(string: ConstArrayPointer<UInt16>, limit: UInt32): String {
		// TODO another version that does not require scanning twice
		return fromUTF16(string: string, offset: 0, chars: countUTF16zUpTo(string, limit))
	}

	static fun fromUTF16z(string: ConstArrayPointer<UInt16>): String {
		// TODO another version that does not require scanning twice
		return fromUTF16(string: string, offset: 0, chars: countUTF16z(string))
	}

	// TODO disallow String? + String (i.e. left/this cannot be null)
	// TODO with may be null
	fun concat(with: String): String {
		let length = with.length + this.length
		let bytes = malloc(length * 2 + 2) as! ArrayPointer<UInt16>
		bytes[length] = 0

		let left: ArrayPointer<UInt16> = bytes as! ArrayPointer<UInt16>
		if this.length > 0 {
			memcpy(left as! ArrayPointer<UInt8>, this.bytes as! ConstArrayPointer<UInt8>, this.length * 2)
		}

		let right: ArrayPointer<UInt16> = ((bytes as! UInt64) + this.length * 2) as! ArrayPointer<UInt16>
		if with.length > 0 {
			memcpy(right as! ArrayPointer<UInt8>, with.bytes as! ConstArrayPointer<UInt8>, with.length * 2)
		}

		return fromUTF16z(bytes as! ConstArrayPointer<UInt16>)
	}

	static fun fromInt32(value: Int): String {
		let bytes = malloc(22) as! ArrayPointer<UInt16>
		for i in 22 {
			bytes[i] = 0
		}
		var value = value
		var pos = 10
		let negative = value < 0

		if negative {
			value = -value
		}

		while value >= 10 {
			// TODO optimize if non-null value in normalizer? wrap to return 0?
			//TODO!!!uncomment
			bytes[pos] = '0'.charCodeAt(0) + (value % 10)
			//
			//bytes[pos] = 48 + (value % 10)
			value = value \ 10
			pos--
		}

		//TODO
		bytes[pos] = 48 + (value % 10)
		pos--

		if negative {
			//TODO
			bytes[pos] = '-'.charCodeAt(0)
		} else {
			pos++
		}

		let bytes = ((bytes as! UInt64) + pos * 2) as! ConstArrayPointer<UInt16>
		return fromUTF16z(bytes as! ConstArrayPointer<UInt16>)
	}
}
//private
@keep
let rootString: String = ''

class Math {
	static fun abs(v: Float): Float {return 0}
	static fun acos(v: Float): Float {return 0}
	static fun asin(v: Float): Float {return 0}
	static fun atan(v: Float): Float {return 0}
	static fun atan2(y: Float, x: Float): Float {return 0}
	static fun ceil(v: Float): Int {return 0}
	static fun cos(v: Float): Float {return 0}
	static fun exp(v: Float): Float {return 0}
	static fun floor(v: Float): Int {return 0}
	static fun log(v: Float): Float {return 0}
	static fun max(a: Float, b: Float): Float {return 0}
	static fun min(a: Float, b: Float): Float {return 0}
	static fun pow(v: Float, exp: Float): Float {return 0}
	static fun random(): Float {return 0}
	static fun round(v: Float): Int {return 0}
	static fun sin(v: Float): Float {return 0}
	static fun sqrt(v: Float): Float {return 0}
	static fun tan(v: Float): Float {return 0}
}

class JSON {
	static fun parse(text: String): Any {return null}
	static fun stringify(value: Any, replacer: (Any, Any)=>Any?, space: String?): String {return ''}
}

class Map<K, V> {
	//fun get(k: K): V {}
	fun get(k: K): V? {return null}
	//fun get(k: K): Any {return null}
	fun set(k: K, v: V): Void {}
	fun has(k: K): Bool {return false}
	fun keys(): [K] {return [null]} // TODO what with [null]?
	new(/*...values: T*/) {} // TODO fix ... in parser
}

@rename('FILE *')
declare
class FILE {}
@rename('stdin') declare let stdin: FILE
@rename('stdout') declare let stdout: FILE
//declare fun ffflush(port: FILE): Void
@rename('fflush') declare fun fflush(port: FILE): Void
@rename('printf') declare fun printf(text: ConstArrayPointer<ClangChar>): Void
@rename('wprintf') declare fun wprintf(text: ConstArrayPointer<ClangWideChar>): Void
@rename('putchar') declare fun putchar(char: Int): Void
@rename('ZeroMemory') declare fun zeroMemory(destination: ArrayPointer<UInt8>, bytes: UInt32): Void

//@rename('wprintf') declare fun wprintf(text: ConstArrayPointer<UInt8>): Void

/*
	#if linux
	@include('#include <stdio.h>', '#include <stdlib.h>')
	@link('-lc')
	#elseif windows
	@importDLL('ntdll.dll')
	#end
	module stdio {

	}

	or...

	/linux/stdio.hexa
	module stdio {}
*/

@final
// TODO ^ make `.log` calls non-virtual
class Console {
	new() {}
	//fun log(str: Any): Void {
	fun log(any: Any): Void {
	}

	fun logString(str: String): Void {
		//let length = str.length + 3
		//let ascii: ArrayPointer<UInt8> = malloc(length) as! ArrayPointer<UInt8>
		wprintf("%s\r\n".wide(), str.bytes)

		//var buffer: ArrayByValue<UInt8, 6> = [
		//	'%'.charCodeAt(0), 'l'.charCodeAt(0), 's'.charCodeAt(0), 13, 10, 0
		//]
		//printf(buffer as! ConstArrayPointer<ClangChar>, str.bytes)

		//let utf16: ConstArrayPointer<UInt16> = str.bytes as! ConstArrayPointer<UInt16>
		//printf("P:%ls\n".wide(), str.wide())

		//ascii[0] = 'H'.charCodeAt(0)
		//ascii[1] = 0

		//for index in str.length {
			//TODO
			//ascii[index] = utf16[index] & 0xFF
			//length++
			//TODO if ascii[index] == 0 {
			//TODO 	break
			//TODO }
			//printf("P:%c\n".wide(), utf16[index] & 0xFF)
			//let u: Int8 = utf16[index]
			//let u: UInt8 = utf16[index]
			//let u: Int = utf16[index]
			//let u: UInt16 = utf16[index]
			//putchar(u)
			//let u: Int = utf16[index]
			//putchar(u)
			//putchar(utf16[index])
		//}

		//putchar(13)
		//putchar(10)

		//TODO
		//ascii[length - 3] = 13
		//TODO
		//ascii[length - 2] = 10
		//TODO
		//ascii[length - 1] = 0
		//printf("%ls\n".wide(), ascii as! ConstArrayPointer<ClangChar>)
		//free(ascii as! RuntimeAllocated)
		//fflush(0 as! FILE)
		fflush(stdout)
	}
	fun error(data: Any, message: String?): Void {}
}

let console: Console = new Console()

class Array<T> {
	// TODO do not store "capacity" - it can be always(?) calculated from length
	var length: Int
	//fun get(index: Int): Int {} // TODO T?
	//fun set(index: Int, value: T): Void {}
	fun concat(a: [T]): [T] {return[]}
	fun join(sep: String): String {return''}
	//fun pop(): T? {}
	fun pop(): T? {return null}
	fun push(x: T): Int {return 0}
	fun reverse(): Void {}
	//fun shift(): T? {}
	fun shift(): T? {return null}
	fun slice(pos: Int, end: Int?): [T] {return[]}
	fun sort(f: (T, T)=>Int): Void {}
	fun splice(pos: Int, len: Int): [T] {return[]}
	fun toString(): String {return ''}
	fun unshift(x: T): Void {}
	fun includes(x: T): Bool {return false}
	fun indexOf(x: T, fromIndex: Int?): Int {return 0}
	fun lastIndexOf(x: T, fromIndex: Int?): Int {return 0}
	fun filter(f: T=>Bool): [T] {return[]}

	// TODO `@noLeave f` means `f` never transferred outside of `fun map`
	// ^ useful for detecting that `f` closure is short-living
	// TODO also means that closure may be STACK ALLOCATED
	fun map(f: T=>T): [T] {return[]}
	//new(...values: T) {} // TODO fix ... in parser
	new(size: Int) {} // TODO fix ... in parser
	//private fun get(index: Int): T {return null}
	//private fun set(index: Int, value: T): T {return null}
	@operator('[]++') fun incrementPost(index: Int): Float {return 0}
	@operator('++[]') fun incrementPre(index: Int): Float {return 0}
}

class InternalArray {}
class IntArray extends InternalArray {}
class StringArray extends InternalArray {}
class FloatArray extends InternalArray {}
class ObjectArray<T> extends InternalArray {}
// TODO declare Array<T> = arrayType(T)

class Date {
	static fun now(): Float {return 0}
}

declare class Reflect { // TODO non-declare!!!
	static fun has(object: Any, name: String): Bool
	static fun get(object: Any, name: String): Any?
	static fun set(object: Any, name: String, value: Any?): Bool
	static fun ownKeys(object: Any): [String]
}

declare fun require(package: String): Any
let __dirname: String = '.'
declare let __filename: String

class Buffer /*implements ArrayAccess<T>*/ {
	static fun alloc/*<T>*/(size: Int): Buffer {return null as! Buffer} // TODO handle `as!` in gen/typer
	var length: Int
	var bytes: ArrayPointer<UInt8>
	private new (bufsize: Int) {}//{return null} // TODO `new` cannot return value
	fun readUInt16LE(offset: Int): Int {return 0}
	fun writeUInt16LE(value: Int, offset: Int): Int {return 0}
	fun readUInt32LE(offset: Int): Int {return 0}
	fun slice(offset: Int): Buffer // {} // TODO class is abstract due to fields fun not have a body
	fun toString(encoding: String): String {return 'null'}//: String, start: Int?, end: Int?): String {}
	static fun fromBytes(data: ArrayPointer<UInt8>, length: Int): Buffer {return null as! Buffer}
	static fun from/*<T>*/(string: String, encoding: String?): Buffer {return null as! Buffer}
}

class ProcessStd {
	fun write(text: String): Void {}
	fun once(name: String, callback: ()=>Void): Void {}
	let fd: Any
}

class NodeProcess {
	static let stdin: ProcessStd
	static let stdout: ProcessStd
	static let stderr: ProcessStd
	static let argv: [String]
	static fun exit(errorCode: Int): Void {}
	static let versions: { node: String }
	fun cwd(): String {return 'null'}
	let env: Any
}

class ProcessT {
	let stdin: ProcessStd
	let stdout: ProcessStd
	let stderr: ProcessStd
	let argv: [String]
	fun exit(errorCode: Int): Void {}
	fun cwd(): String {return 'null'}
	let versions: { node: String } // todo not require value = for lets in declare
	let env: Any // todo not require value = for lets in declare
}

declare let process: ProcessT

class ParsedPath {
	var root: String
	var dir: String
	var base: String
	var ext: String
	var name: String
}

class Path {
	static let sep: String
	static fun resolve(path: String): String {return 'null'}
	static fun parse(path: String): ParsedPath {return null as! ParsedPath}
	static fun join(...path: String): String {return 'null'}
}

class Fs {
	static fun writeFileSync(path: String, data: String): Void {}
	static fun readdirSync(path: String): [String] {return [null]}
	static fun readFileSync(path: String): Buffer {return null as! Buffer}
	static fun lstatSync(path: String): Any {return null}
	static fun existsSync(path: String): Bool {return false}
	static fun mkdirSync(path: String): Void {}
	static fun readSync(fd: Int, buffer: Buffer, offset: Int, length: Int, position: Int): Int {return 0}
	static fun openSync(path: String, flags: String): Int {return 0}
	static fun renameSync(oldPath: String, newPath: String): Void {}
}

@require("fs")
declare let fssss: ProcessT

// Global
@rename('undefined') declare let undefined: Any?
declare fun encodeURIComponent(s: String): String
declare fun decodeURIComponent(s: String): String
declare fun typeof(v: Any): String
declare fun __js__(code: String): Any
declare fun eval(code: String): Any
// Special-case, returns `null` instead of `NaN`
declare fun parseInt(text: String): Int
declare fun parseFloat(text: String): Float

fun btoa(text: String) {
	return Buffer.from(text, 'binary').toString('base64')
}

fun atob(base64: String) {
	return Buffer.from(base64, 'base64').toString('binary')
}

// TODO decorator of module parsing @rename('global')
//module js
// Just native built-in `parseInt`, without special cases
//declare fun parseInt(text: String): Int
//declare fun parseFloat(text: String): Float
